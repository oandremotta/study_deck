import 'package:flutter/foundation.dart';

/// Result of AI-generated pedagogical fields (UC188/UC190).
class PedagogicalFields {
  /// Short answer/summary (≤240 chars).
  final String summary;

  /// Memory anchor phrase (≤120 chars).
  final String keyPhrase;

  /// Optional hint.
  final String? hint;

  /// AI confidence score (0-1).
  final double confidenceScore;

  /// Whether this needs human review.
  final bool needsReview;

  const PedagogicalFields({
    required this.summary,
    required this.keyPhrase,
    this.hint,
    this.confidenceScore = 0.85,
    this.needsReview = false,
  });
}

/// Represents a card generated by AI in pedagogical format.
///
/// Pedagogical structure (UC167):
/// - [question]: The question/prompt
/// - [summary]: Short answer (≤240 chars) - main answer shown first
/// - [keyPhrase]: Memory anchor phrase (≤120 chars) - helps memorization
/// - [explanation]: Full explanation (optional) - for deeper understanding
class GeneratedCard {
  /// The question (maps to Card.front).
  final String front;

  /// Full explanation (maps to Card.back for backward compatibility).
  final String back;

  /// Short answer/summary (≤240 chars).
  final String? summary;

  /// Memory anchor phrase (≤120 chars).
  final String? keyPhrase;

  /// Optional hint.
  final String? hint;

  /// Difficulty level.
  final String difficulty;

  /// Suggested tags for organization.
  final List<String> suggestedTags;

  /// AI confidence score (0-1).
  final double confidenceScore;

  /// Whether this card needs human review (UC168).
  final bool needsReview;

  const GeneratedCard({
    required this.front,
    required this.back,
    this.summary,
    this.keyPhrase,
    this.hint,
    this.difficulty = 'medium',
    this.suggestedTags = const [],
    this.confidenceScore = 0.8,
    this.needsReview = false,
  });

  /// Returns true if the card has all pedagogical fields filled.
  bool get hasPedagogicalFields =>
      summary != null &&
      summary!.isNotEmpty &&
      keyPhrase != null &&
      keyPhrase!.isNotEmpty;

  @override
  String toString() =>
      'GeneratedCard(front: ${front.length > 30 ? '${front.substring(0, 30)}...' : front}, needsReview: $needsReview)';
}

/// Configuration for AI generation.
class AiGenerationRequest {
  /// Content to generate cards from (text or topic).
  final String content;

  /// Number of cards to generate.
  final int cardCount;

  /// Difficulty level: 'easy', 'medium', 'hard', 'mixed'.
  final String difficulty;

  /// Target language for cards.
  final String language;

  /// Whether to include hints.
  final bool includeHints;

  /// Whether the content is a topic (vs extracted text).
  final bool isTopic;

  const AiGenerationRequest({
    required this.content,
    this.cardCount = 10,
    this.difficulty = 'medium',
    this.language = 'pt-BR',
    this.includeHints = true,
    this.isTopic = false,
  });
}

/// Available AI providers.
enum AiProvider {
  gemini,
  openai,
}

extension AiProviderExtension on AiProvider {
  String get displayName {
    switch (this) {
      case AiProvider.gemini:
        return 'Google Gemini';
      case AiProvider.openai:
        return 'OpenAI';
    }
  }

  String get value {
    switch (this) {
      case AiProvider.gemini:
        return 'gemini';
      case AiProvider.openai:
        return 'openai';
    }
  }

  static AiProvider fromValue(String value) {
    switch (value) {
      case 'openai':
        return AiProvider.openai;
      case 'gemini':
      default:
        return AiProvider.gemini;
    }
  }
}

/// Abstract interface for AI card generation services.
///
/// Implementations:
/// - [GeminiGenerationService] - Google Gemini API
/// - [OpenAiGenerationService] - OpenAI API
///
/// Usage:
/// ```dart
/// final service = GeminiGenerationService(apiKey: 'your-key');
/// final cards = await service.generateCards(request);
/// ```
abstract class AiGenerationService {
  /// The AI provider this service uses.
  AiProvider get provider;

  /// Generates flashcards from content.
  ///
  /// [request] contains the content and configuration.
  /// Returns a list of generated cards.
  Future<List<GeneratedCard>> generateCards(AiGenerationRequest request);

  /// Refines a single card based on feedback.
  ///
  /// [originalFront] - the original front text
  /// [originalBack] - the original back text
  /// [feedback] - user feedback for improvement
  Future<GeneratedCard> refineCard({
    required String originalFront,
    required String originalBack,
    required String feedback,
  });

  /// Generates pedagogical fields (summary and keyPhrase) for an existing card.
  ///
  /// UC188/UC190: AI generation of pedagogical fields for manual cards.
  /// [question] - the card's question (front)
  /// [answer] - the card's answer (back/explanation)
  Future<PedagogicalFields> generatePedagogicalFields({
    required String question,
    required String answer,
  });

  /// Estimates the cost of generating cards.
  ///
  /// Returns estimated cost in USD.
  double estimateCost(AiGenerationRequest request);

  /// Builds the prompt for card generation in pedagogical format (UC167).
  ///
  /// The prompt asks for structured cards with:
  /// - question: The question/prompt
  /// - summary: Short answer (max 240 chars)
  /// - keyPhrase: Memory anchor phrase (max 120 chars)
  /// - explanation: Full explanation (optional)
  @protected
  String buildGenerationPrompt(AiGenerationRequest request) {
    final difficultyGuide = _getDifficultyGuide(request.difficulty);
    final hintsSection = request.includeHints
        ? '\n- Inclua uma dica (hint) curta para cada card que ajude a lembrar a resposta sem revelar diretamente.'
        : '';

    final pedagogicalInstructions = '''
FORMATO PEDAGOGICO OBRIGATORIO:
Cada card DEVE seguir esta estrutura para facilitar a memorizacao:

1. question: A pergunta clara e objetiva
2. summary: Resposta CURTA (maximo 240 caracteres) - sera mostrada primeiro ao estudar
3. keyPhrase: Frase-chave de memoria (maximo 120 caracteres) - uma frase afirmativa simples que ancora o conceito
4. explanation: Explicacao completa (opcional) - detalhes adicionais para aprofundamento

REGRAS IMPORTANTES:
- O summary NAO pode ser igual a pergunta
- O keyPhrase DEVE ser uma frase afirmativa (NAO uma pergunta, NAO terminar com ?)
- O keyPhrase deve capturar a essencia do conceito em uma frase memoravel
- O summary deve ser uma resposta direta e concisa''';

    if (request.isTopic) {
      return '''
Voce e um especialista em educacao e criacao de flashcards com tecnicas de aprendizado eficaz.
Gere ${request.cardCount} flashcards sobre o seguinte assunto: "${request.content}"

$pedagogicalInstructions

Regras adicionais:
- Use linguagem ${request.language == 'pt-BR' ? 'portuguesa do Brasil' : request.language}
- $difficultyGuide$hintsSection
- Sugira 1-2 tags relevantes para cada card
- Varie os tipos de pergunta: definicoes, conceitos, exemplos, comparacoes

Retorne APENAS um JSON valido no seguinte formato (sem markdown, sem explicacoes):
{
  "cards": [
    {
      "question": "pergunta clara",
      "summary": "resposta curta (max 240 chars)",
      "keyPhrase": "frase-chave memoravel (max 120 chars)",
      "explanation": "explicacao completa opcional",
      ${request.includeHints ? '"hint": "dica",' : ''}
      "difficulty": "easy|medium|hard",
      "tags": ["tag1", "tag2"]
    }
  ]
}''';
    }

    return '''
Voce e um especialista em educacao e criacao de flashcards com tecnicas de aprendizado eficaz.
Analise o seguinte texto e gere ${request.cardCount} flashcards que capturem os conceitos mais importantes:

"""
${request.content}
"""

$pedagogicalInstructions

Regras adicionais:
- Use linguagem ${request.language == 'pt-BR' ? 'portuguesa do Brasil' : request.language}
- $difficultyGuide$hintsSection
- Sugira 1-2 tags relevantes para cada card
- Foque nos conceitos principais, evite detalhes triviais
- Varie os tipos de pergunta: definicoes, conceitos, exemplos, comparacoes

Retorne APENAS um JSON valido no seguinte formato (sem markdown, sem explicacoes):
{
  "cards": [
    {
      "question": "pergunta clara",
      "summary": "resposta curta (max 240 chars)",
      "keyPhrase": "frase-chave memoravel (max 120 chars)",
      "explanation": "explicacao completa opcional",
      ${request.includeHints ? '"hint": "dica",' : ''}
      "difficulty": "easy|medium|hard",
      "tags": ["tag1", "tag2"]
    }
  ]
}''';
  }

  /// Builds the prompt for card refinement.
  @protected
  String buildRefinePrompt({
    required String originalFront,
    required String originalBack,
    required String feedback,
  }) {
    return '''
Voce e um especialista em educacao e criacao de flashcards.
Refine o seguinte flashcard baseado no feedback do usuario:

Card original:
- Frente: "$originalFront"
- Verso: "$originalBack"

Feedback do usuario: "$feedback"

Melhore o card mantendo o conceito original mas aplicando o feedback.

Retorne APENAS um JSON valido (sem markdown):
{
  "front": "nova pergunta",
  "back": "nova resposta",
  "hint": "dica opcional",
  "difficulty": "easy|medium|hard",
  "tags": ["tag1"]
}''';
  }

  String _getDifficultyGuide(String difficulty) {
    switch (difficulty) {
      case 'easy':
        return 'Crie cards faceis, com perguntas diretas e respostas curtas';
      case 'hard':
        return 'Crie cards desafiadores, que exijam compreensao profunda';
      case 'mixed':
        return 'Varie a dificuldade dos cards (alguns faceis, medios e dificeis)';
      case 'medium':
      default:
        return 'Crie cards de dificuldade media, equilibrando clareza e profundidade';
    }
  }
}
